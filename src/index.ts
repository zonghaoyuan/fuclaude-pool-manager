// src/index.ts
/**
 * Cloudflare Worker for managing Claude API access through session keys (SKs).
 * Provides endpoints for users to login (randomly or specifically) and for admins to manage SKs.
 * Utilizes KV storage for email-to-SK mappings and supports optional Sentry integration for error tracking.
 */

// --- Type Definitions ---

/**
 * Defines the environment variables and bindings expected by the Worker.
 * These are configured in the Cloudflare dashboard or via wrangler.toml/wrangler.jsonc.
 */
interface Env {
  /**
   * The KV Namespace used to store the email-to-SK mapping.
   * This is where `EMAIL_TO_SK_MAP` key holds the JSON string of mappings.
   */
  CLAUDE_KV: KVNamespace;
  /**
   * The password required for accessing administrative endpoints (e.g., /api/admin/*).
   * This should be set as a Secret in the Worker's settings.
   */
  ADMIN_PASSWORD: string;
  /**
   * The base URL for the Claude API (e.g., https://demo.fuclaude.com).
   * Used to construct the final login URL.
   */
  BASE_URL: string;
  /**
  /**
   * Optional: The token expiration time in seconds.
   * Defaults to 0 (never expires) if not set.
   * Can be overridden by the 'expires_in' parameter in the login request.
   */
  TOKEN_EXPIRES_IN?: string;
}

/**
 * Represents the structure of the email to session key mapping stored in KV.
 * Keys are email addresses (string), and values are their corresponding session keys (sk, string).
 */
interface EmailSkMap {
  [email: string]: string;
}

/**
 * Defines the structure of the request body for the /api/login endpoint.
 */
interface LoginRequest {
  /**
   * The mode of login: 'specific' (requires email and unique_name) or 'random'.
   */
  mode: 'specific' | 'random';
  /**
   * Optional: The email address for 'specific' mode login.
   */
  email?: string;
  /**
   * Optional: A unique identifier for the session, required for 'specific' mode.
   * For 'random' mode, this is generated by the worker.
   */
  unique_name?: string;
  /**
   * Optional: The desired token expiration time in seconds.
   * Overrides the default and the TOKEN_EXPIRES_IN environment variable.
   * A value of 0 means the token should not expire.
   */
  expires_in?: number;
}

/**
 * Defines the structure of the request body for the /api/admin/login endpoint.
 * Inherits from LoginRequest and requires an admin password.
 */
interface AdminLoginRequest extends LoginRequest, AdminRequestBase {}

/**
 * Base interface for administrative requests, requiring an admin password.
 */
interface AdminRequestBase {
  /**
   * The password to authenticate administrative actions.
   * Must match the ADMIN_PASSWORD secret.
   */
  admin_password: string;
}

/**
 * Defines the structure for adding a new email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminAddRequest extends AdminRequestBase {
  /**
   * The email address to add or update.
   */
  email: string;
  /**
   * The session key (sk) associated with the email.
   */
  sk: string;
}

/**
 * Defines the structure for deleting an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminDeleteRequest extends AdminRequestBase {
  /**
   * The email address to delete from the mapping.
   */
  email: string;
}

/**
 * Defines the structure for updating an email-SK pair via an admin endpoint.
 * Inherits admin_password from AdminRequestBase.
 */
interface AdminUpdateRequest extends AdminRequestBase {
  /**
   * The current email address to identify the record to be updated.
   */
  email: string;
  /**
   * Optional: The new email address to replace the old one.
   */
  new_email?: string;
  /**
   * Optional: The new session key to replace the old one.
   */
  new_sk?: string;
 }
 
 /**
  * Defines a single action within a batch request.
  */
 interface AdminBatchAction {
   action: 'add' | 'delete';
   email: string;
   sk?: string; // Required for 'add', ignored for 'delete'
 }
 
 /**
  * Defines the structure for a batch processing request.
  * Inherits admin_password from AdminRequestBase.
  */
 interface AdminBatchRequest extends AdminRequestBase {
   actions: AdminBatchAction[];
 }
 
 // --- Helper Functions ---

/**
 * Creates a JSON response with appropriate CORS headers.
 * @param data The data to be stringified into the response body.
 * @param status The HTTP status code for the response (default is 200).
 * @param extraHeaders Additional headers to include in the response.
 * @returns A Response object.
 */
const jsonResponse = (data: any, status = 200, extraHeaders = {}) => {
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*', // Allow all origins
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS', // Allow common methods
    'Access-Control-Allow-Headers': 'Content-Type, Authorization', // Allow necessary headers
    ...extraHeaders,
  };
  return new Response(JSON.stringify(data, null, 2), { status, headers });
};

/**
 * Handles CORS preflight (OPTIONS) requests.
 * @param request The incoming Request object.
 * @returns A Response object with appropriate CORS headers for preflight.
 */
const handleOptions = (request: Request) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  };
  return new Response(null, { headers }); // No body for OPTIONS response
};

/**
 * Sorts an array of email addresses, primarily by domain, then by the local part.
 * @param emails An array of email strings.
 * @returns A new array with sorted email strings.
 */
const sortEmails = (emails: string[]): string[] => {
  return emails.sort((a, b) => {
    const [, domainA = ''] = a.split('@'); // Robust split with default
    const [, domainB = ''] = b.split('@');
    if (domainA !== domainB) {
      return domainA.localeCompare(domainB); // Sort by domain first
    }
    return a.localeCompare(b); // Then by full email
  });
};

/**
 * Retrieves and parses the EMAIL_TO_SK_MAP from KV storage.
 * @param env The Environment object containing the KV namespace.
 * @returns A Promise that resolves to the EmailSkMap object. Returns an empty object if not found or on parse error.
 */
async function getEmailSkMap(env: Env): Promise<EmailSkMap> {
  const mapStr = await env.CLAUDE_KV.get('EMAIL_TO_SK_MAP');
  if (!mapStr) {
    console.log("EMAIL_TO_SK_MAP not found in KV, returning empty map.");
    return {}; // Return an empty object if KV key doesn't exist
  }
  try {
    return JSON.parse(mapStr) as EmailSkMap;
  } catch (e) {
    console.error("Error parsing EMAIL_TO_SK_MAP from KV:", e);
    return {}; // Return empty on parse error to prevent worker crashes
  }
}

// --- Main Worker Fetch Handler ---
export default {
  /**
   * Handles incoming HTTP requests to the Worker.
   * @param request The incoming Request object.
   * @param env The Environment object with bindings and secrets.
   * @param ctx The ExecutionContext for the request.
   * @returns A Promise that resolves to a Response object.
   */
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Handle CORS preflight requests first
    if (request.method === 'OPTIONS') {
      return handleOptions(request);
    }


    try {
      const url = new URL(request.url);

      // --- User Endpoints ---

      // GET /api/emails: Lists available email addresses (sorted)
      if (url.pathname === '/api/emails' && request.method === 'GET') {
        const emailMap = await getEmailSkMap(env);
        const sortedEmails = sortEmails(Object.keys(emailMap));
        return jsonResponse({ emails: sortedEmails });
      }

      // POST /api/login: Handles user login requests (specific or random)
      if (url.pathname === '/api/login' && request.method === 'POST') {
        let body: LoginRequest;
        try {
          body = await request.json();
        } catch (e) {
          return jsonResponse({ error: 'Invalid JSON request body.' }, 400);
        }

        const emailMap = await getEmailSkMap(env);
        let sk: string | undefined;
        let uniqueName: string;
        let selectedEmailForLog: string | undefined; // For logging purposes

        if (body.mode === 'random') {
          const emails = Object.keys(emailMap);
          if (emails.length === 0) {
            return jsonResponse({ error: 'No accounts available for random selection' }, 503); // Service Unavailable
          }
          selectedEmailForLog = emails[Math.floor(Math.random() * emails.length)];
          sk = emailMap[selectedEmailForLog];
          uniqueName = `rand_${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`; // More unique random name
        } else if (body.mode === 'specific') {
          if (!body.email || !body.unique_name) {
            return jsonResponse({ error: 'Email and unique_name are required for specific mode' }, 400);
          }
          selectedEmailForLog = body.email;
          sk = emailMap[selectedEmailForLog];
          uniqueName = body.unique_name;
        } else {
          return jsonResponse({ error: 'Invalid login mode specified. Must be \"specific\" or \"random\".' }, 400);
        }

        if (!sk) {
          const errorMessage = `Account for ${selectedEmailForLog || 'random selection'} not found or SK is invalid`;
          console.error(`Login attempt for ${selectedEmailForLog || 'random'} failed: SK not found.`);
          return jsonResponse({ error: errorMessage }, 404); // Not Found
        }

        // --- Token Expiration Logic for User Endpoint ---
        let expiresIn: number;
        let warning: string | undefined;
        const maxExpiresIn = env.TOKEN_EXPIRES_IN ? parseInt(env.TOKEN_EXPIRES_IN, 10) : 0;

        if (typeof body.expires_in === 'number') {
          expiresIn = body.expires_in;
          // If a maximum duration is set via environment variable and it's not 0 (unlimited)
          if (maxExpiresIn > 0 && expiresIn > maxExpiresIn) {
            warning = `Requested expiration of ${expiresIn}s exceeds the maximum allowed of ${maxExpiresIn}s. The expiration has been adjusted.`;
            expiresIn = maxExpiresIn;
          }
        } else {
          // Default to the max allowed if not specified in request
          expiresIn = isNaN(maxExpiresIn) ? 0 : maxExpiresIn;
        }

        // --- Claude API Token Exchange ---
        const oauthPayload = { session_key: sk, unique_name: uniqueName, expires_in: expiresIn };
        const oauthResponse = await fetch(`${env.BASE_URL}/manage-api/auth/oauth_token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(oauthPayload),
        });

        if (!oauthResponse.ok) {
          const errorText = await oauthResponse.text();
          const logMessage = `Token exchange failed for ${selectedEmailForLog} (SK preview: ${sk.slice(0,15)}...): ${oauthResponse.status}`;
          console.error(`${logMessage} - Response: ${errorText}`);
          throw new Error(`Token exchange failed with status ${oauthResponse.status}. Check server logs for details.`);
        }
        
        const oauthData: any = await oauthResponse.json();
        if (!oauthData.login_url) {
            const logMessage = `Token exchange response for ${selectedEmailForLog} missing login_url.`;
            console.error(`${logMessage} - Response: ${JSON.stringify(oauthData)}`);
            throw new Error('Token exchange successful, but login_url was not returned.');
        }

        const responsePayload: { login_url: string; warning?: string } = {
          login_url: `${env.BASE_URL}${oauthData.login_url}`
        };
        if (warning) {
          responsePayload.warning = warning;
        }
        return jsonResponse(responsePayload);
      }

      // --- Admin Endpoints (prefixed with /api/admin) ---
      if (url.pathname.startsWith('/api/admin')) {
        // Centralized admin password extraction and validation for POST, PUT, DELETE
        if (request.method === 'POST' || request.method === 'PUT' || request.method === 'DELETE') {
          let adminRequestData: AdminRequestBase;
          try {
            adminRequestData = await request.clone().json(); // Clone for body re-read if needed
          } catch (e) {
            return jsonResponse({ error: 'Invalid JSON body for admin request.' }, 400);
          }
          if (adminRequestData.admin_password !== env.ADMIN_PASSWORD) {
            return jsonResponse({ error: 'Unauthorized. Invalid admin password.' }, 401);
          }
        }
        
        // POST /api/admin/list: Lists all email-SK pairs (requires admin password in body)
        if (url.pathname === '/api/admin/list' && request.method === 'POST') {
            // Password check is now handled by the centralized logic above for POST requests
            const emailMap = await getEmailSkMap(env);
            const sortedEmails = sortEmails(Object.keys(emailMap));
            const listWithIndexAndPreview = sortedEmails.map((email, index) => ({
                index: index + 1,
                email: email,
                sk_preview: emailMap[email] ? `${emailMap[email].slice(0, 20)}...${emailMap[email].slice(-10)}` : "SK_INVALID_OR_MISSING" // Show a safer preview
            }));
            return jsonResponse(listWithIndexAndPreview);
        }

        // POST /api/admin/login: Admin version of the login endpoint with no expiration limits
        if (url.pathname === '/api/admin/login' && request.method === 'POST') {
            const body: AdminLoginRequest = await request.json();
            const emailMap = await getEmailSkMap(env);
            let sk: string | undefined;
            let uniqueName: string;
            let selectedEmailForLog: string | undefined;

            if (body.mode === 'random') {
                const emails = Object.keys(emailMap);
                if (emails.length === 0) {
                    return jsonResponse({ error: 'No accounts available for random selection' }, 503);
                }
                selectedEmailForLog = emails[Math.floor(Math.random() * emails.length)];
                sk = emailMap[selectedEmailForLog];
                uniqueName = `rand_${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;
            } else if (body.mode === 'specific') {
                if (!body.email || !body.unique_name) {
                    return jsonResponse({ error: 'Email and unique_name are required for specific mode' }, 400);
                }
                selectedEmailForLog = body.email;
                sk = emailMap[selectedEmailForLog];
                uniqueName = body.unique_name;
            } else {
                return jsonResponse({ error: 'Invalid login mode specified. Must be "specific" or "random".' }, 400);
            }

            if (!sk) {
                const errorMessage = `Account for ${selectedEmailForLog || 'random selection'} not found or SK is invalid`;
                return jsonResponse({ error: errorMessage }, 404);
            }

            // Admin has no expiration limit, defaults to 0 if not provided.
            const expiresIn = typeof body.expires_in === 'number' ? body.expires_in : 0;

            const oauthPayload = { session_key: sk, unique_name: uniqueName, expires_in: expiresIn };
            const oauthResponse = await fetch(`${env.BASE_URL}/manage-api/auth/oauth_token`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(oauthPayload),
            });

            if (!oauthResponse.ok) {
                const errorText = await oauthResponse.text();
                const logMessage = `Admin Token exchange failed for ${selectedEmailForLog}: ${oauthResponse.status}`;
                console.error(`${logMessage} - Response: ${errorText}`);
                throw new Error(`Token exchange failed with status ${oauthResponse.status}.`);
            }
            
            const oauthData: any = await oauthResponse.json();
            if (!oauthData.login_url) {
                throw new Error('Token exchange successful, but login_url was not returned.');
            }
            return jsonResponse({ login_url: `${env.BASE_URL}${oauthData.login_url}` });
        }

        // POST /api/admin/add: Adds a new email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/add' && request.method === 'POST') {
            const body: AdminAddRequest = await request.json(); // Re-read body, safe as password check cloned
            if (!body.email || !body.sk) {
                return jsonResponse({ error: 'Email and SK are required for adding an account.' }, 400);
            }
            const emailMap = await getEmailSkMap(env);
            if (emailMap[body.email]) {
                return jsonResponse({ error: `Email ${body.email} already exists. Use update if intended.` }, 409); // 409 Conflict
            }
            emailMap[body.email] = body.sk;
            await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
            console.log(`Admin action: Account ${body.email} added successfully.`);
            return jsonResponse({ message: `Account ${body.email} added successfully.` });
        }

        // POST /api/admin/delete: Deletes an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/delete' && request.method === 'POST') {
             const body: AdminDeleteRequest = await request.json(); // Re-read body
             if (!body.email) {
                 return jsonResponse({ error: 'Email is required for deleting an account.' }, 400);
             }
             const emailMap = await getEmailSkMap(env);
             if (!emailMap[body.email]) {
                 return jsonResponse({ error: `Email ${body.email} not found. Cannot delete.` }, 404);
             }
             delete emailMap[body.email];
             await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
             console.log(`Admin action: Account ${body.email} deleted successfully.`);
             return jsonResponse({ message: `Account ${body.email} deleted successfully.` });
        }

        // POST /api/admin/update: Updates an email-SK pair
        // Password check already happened above for POST requests
        if (url.pathname === '/api/admin/update' && request.method === 'POST') {
            const body: AdminUpdateRequest = await request.json();
            if (!body.email) {
                return jsonResponse({ error: 'The original email is required to identify the account to update.' }, 400);
            }
            if (!body.new_email && !body.new_sk) {
                return jsonResponse({ error: 'Either new_email or new_sk must be provided to perform an update.' }, 400);
            }

            const emailMap = await getEmailSkMap(env);

            if (!emailMap[body.email]) {
                return jsonResponse({ error: `Account for ${body.email} not found. Cannot update.` }, 404);
            }

            // Check for new_email conflict before proceeding
            if (body.new_email && body.new_email !== body.email && emailMap[body.new_email]) {
                return jsonResponse({ error: `The new email ${body.new_email} already exists. Cannot update.` }, 409);
            }
            
            // Store the original SK before any potential modification
            const originalSk = emailMap[body.email];

            // If renaming the email, we must delete the old entry
            if (body.new_email && body.new_email !== body.email) {
                delete emailMap[body.email];
            }
            
            // Determine the final email key and SK value
            const finalEmail = body.new_email || body.email;
            const finalSk = body.new_sk || originalSk;

            emailMap[finalEmail] = finalSk;

            await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
            console.log(`Admin action: Account ${body.email} updated successfully. New details -> Email: ${finalEmail}, SK updated: ${!!body.new_sk}`);
            return jsonResponse({ message: `Account ${body.email} has been updated successfully.` });
        }
        
        // POST /api/admin/batch: Processes multiple add/delete operations in one request
        if (url.pathname === '/api/admin/batch' && request.method === 'POST') {
            const body: AdminBatchRequest = await request.json();
            if (!body.actions || !Array.isArray(body.actions)) {
                return jsonResponse({ error: 'The "actions" array is required for batch processing.' }, 400);
            }

            const emailMap = await getEmailSkMap(env);
            const results = [];
            let modified = false;

            for (const item of body.actions) {
                switch (item.action) {
                    case 'add':
                        if (!item.email || !item.sk) {
                            results.push({ email: item.email, status: 'failed', reason: 'Email and SK are required for add action.' });
                            continue;
                        }
                        if (emailMap[item.email]) {
                            // To make it idempotent, we can treat adding an existing key as an update.
                            emailMap[item.email] = item.sk;
                            results.push({ email: item.email, status: 'updated' });
                        } else {
                            emailMap[item.email] = item.sk;
                            results.push({ email: item.email, status: 'added' });
                        }
                        modified = true;
                        break;
                    
                    case 'delete':
                        if (!item.email) {
                            results.push({ email: 'N/A', status: 'failed', reason: 'Email is required for delete action.' });
                            continue;
                        }
                        if (emailMap[item.email]) {
                            delete emailMap[item.email];
                            results.push({ email: item.email, status: 'deleted' });
                            modified = true;
                        } else {
                            results.push({ email: item.email, status: 'skipped', reason: 'Email not found.' });
                        }
                        break;

                    default:
                        results.push({ email: item.email, status: 'failed', reason: `Unknown action: ${item.action}` });
                }
            }

            if (modified) {
                await env.CLAUDE_KV.put('EMAIL_TO_SK_MAP', JSON.stringify(emailMap));
                console.log(`Admin action: Batch processing completed with ${body.actions.length} actions.`);
            }

            return jsonResponse({ message: 'Batch processing complete.', results });
        }

        // If an admin path was hit but not any of the specific routes above
        return jsonResponse({ error: 'Admin endpoint not found.' }, 404);

      } // End of /api/admin block

      // Fallback for any other route not matched
      return jsonResponse({ error: 'Not Found. The requested endpoint does not exist.' }, 404);

    } catch (error: any) {
      console.error("Worker encountered an unhandled error:", error.stack || error);
      // Return a generic error message to the client
      return jsonResponse({ error: 'An internal server error occurred. Please try again later.' }, 500);
    }
  },
};